---
description: 'Instructions for writing Dart and Flutter code following the official recommendations.'
applyTo: '**/*.dart'
---

# Dart 和 Flutter

由 Dart 和 Flutter 團隊推薦的最佳實踐。這些指導文件取自 [Effective Dart](https://dart.dev/effective-dart) 和 [架構建議](https://docs.flutter.dev/app-architecture/recommendations)。

## 有效的 Dart

在過去幾年，我們撰寫了大量的 Dart 程式碼，學到了許多關於什麼有效、什麼無效的知識。我們想與你分享，讓你也能寫出一致、穩健且快速的程式碼。有兩個核心主題：

1.  **保持一致。** 對於格式設定和大小寫等事項，哪個更好的爭論是主觀的，無法解決。我們知道的是 *一致性* 在客觀上是有幫助的。

    如果兩段程式碼看起來不同，那應該是因為它們在某種有意義的方式上 *確實* 不同。當程式碼片段引起你的注意時，應該是出於有用的原因。

2.  **簡潔扼要。** Dart 的設計初衷是熟悉易用，因此繼承了許多與 C、Java、JavaScript 和其他語言相同的陳述式和運算式。但我們建立 Dart 是因為在這些語言所提供的基礎上有很大的改進空間。我們新增了許多功能，從字串插補到初始化形式參數，幫助你更簡單、更容易地表達你的意圖。

    如果有多種方式表達某個概念，你通常應該選擇最簡潔的方式。這不是說你應該把整個程式 `code golf` 到單一行。目標是 *經濟* 的程式碼，而不是 *密集* 的程式碼。

### 主題

我們將指導方針分為幾個單獨的主題，便於消化吸收：

*   **風格** – 這定義了代碼佈局和組織的規則，或至少是 `dart format` 不會為你處理的部分。風格主題也規定了識別符的格式化方式：`camelCase`、`using_underscores` 等。

*   **文件** – 這告訴你關於註解內部內容的一切。包括文件註解和常規程式碼註解。

*   **使用** – 這教你如何充分利用語言功能來實現行為。如果它在陳述式或運算式中，這裡就會涵蓋。

*   **設計** – 這是最柔軟的主題，但範圍最廣。它涵蓋了我們在設計一致、易用的函式庫 API 時所學到的內容。如果它在類型簽章或宣告中，這部分就會討論。

### 如何閱讀主題

每個主題都分為幾個小節。小節包含一列指導方針。每個指導方針都以這些字之一開頭：

*   **應該（DO）** 指導方針描述了應該始終遵循的做法。幾乎不會有正當理由偏離它們。

*   **不應該（DON'T）** 指導方針相反：幾乎從不是好主意的事情。希望我們的數量不會像其他語言一樣多，因為我們歷史包袱較少。

*   **建議（PREFER）** 指導方針是你 *應該* 遵循的做法。然而，在某些情況下，做別的事情可能是有意義的。只要確保你理解了當你忽視指導方針時的完整含義。

*   **避免（AVOID）** 指導方針與「建議」相對：你不應該做的事情，但在罕見情況下可能有充分理由這樣做。

*   **考慮（CONSIDER）** 指導方針是你可能想也可能不想遵循的做法，這取決於情況、先例和你自己的偏好。

某些指導方針描述了規則 *不適用* 的 **例外情況**。列出時，例外情況可能並不詳盡——你在其他情況下仍可能需要發揮判斷力。

這聽起來像是如果你沒有正確繫鞋帶，警察就會來敲你的門。事實並非如此。這裡大多數指導方針都是常識，我們都是理性的人。目標始終是漂亮、可讀且可維護的程式碼。

### 規則

#### 風格

##### 識別符

*   應該使用 `UpperCamelCase` 命名類型。
*   應該使用 `UpperCamelCase` 命名擴充套件。
*   應該使用 `lowercase_with_underscores` 命名套件、目錄和原始程式碼檔案。
*   應該使用 `lowercase_with_underscores` 命名匯入前綴。
*   應該使用 `lowerCamelCase` 命名其他識別符。
*   建議對常數名稱使用 `lowerCamelCase`。
*   應該將長於兩個字母的縮寫和首字母縮寫詞大寫，就像單字一樣。
*   建議對未使用的回呼參數使用萬用字元。
*   不應該在非私有識別符上使用前導底線。
*   不應該使用前綴字母。
*   不應該明確命名函式庫。

##### 順序

*   應該在其他匯入之前放置 `dart:` 匯入。
*   應該在相對匯入之前放置 `package:` 匯入。
*   應該在所有匯入之後的單獨部分中指定匯出。
*   應該按字母順序排序部分。

##### 格式化

*   應該使用 `dart format` 格式化你的程式碼。
*   考慮修改你的程式碼以使其更便於格式化工具處理。
*   建議採用 80 個字元或更少的行長。
*   應該對所有控制流陳述式使用大括號。

#### 文件

##### 註解

*   應該將註解格式化為句子。
*   不應該使用區塊註解來進行文件。

##### 文件註解

*   應該使用 `///` 文件註解來記錄成員和類型。
*   建議為公開 API 撰寫文件註解。
*   考慮撰寫函式庫級別的文件註解。
*   考慮為私有 API 撰寫文件註解。
*   應該以單一句子摘要開始文件註解。
*   應該將文件註解的第一句分離到自己的段落中。
*   避免與周圍內容重複。
*   如果函式或方法的主要目的是副作用，建議以第三人稱動詞開始註解。
*   建議以名詞片語開始非布林變數或屬性註解。
*   建議以「是否」（Whether）開始布林變數或屬性註解，後跟名詞或現在分詞片語。
*   如果函式或方法的主要目的是傳回值，建議使用名詞片語或非命令式動詞片語。
*   不應該同時為屬性的取得方法和設定方法撰寫文件。
*   建議以名詞片語開始函式庫或類型註解。
*   考慮在文件註解中包括程式碼範例。
*   應該在文件註解中使用方括號來參考範圍內的識別符。
*   應該使用散文來解釋參數、傳回值和例外。
*   應該將文件註解放在中繼資料註釋之前。

##### Markdown

*   避免過度使用 markdown。
*   避免使用 HTML 進行格式化。
*   建議對程式碼區塊使用反引號柵欄。

##### 撰寫

*   建議簡潔扼要。
*   避免使用縮寫和首字母縮寫詞，除非它們很明顯。
*   建議使用「this」而不是「the」來指代成員的實例。

#### 使用

##### 函式庫

*   應該在 `part of` 指令中使用字串。
*   不應該匯入位於另一個套件的 `src` 目錄內的函式庫。
*   不應該允許匯入路徑到達或超出 `lib`。
*   建議使用相對匯入路徑。

##### 空值

*   不應該明確地將變數初始化為 `null`。
*   不應該使用明確的 `null` 預設值。
*   不應該在相等比較中使用 `true` 或 `false`。
*   如果需要檢查變數是否已初始化，避免使用 `late` 變數。
*   考慮使用類型提升或空值檢查模式來使用可為空的類型。

##### 字串

*   應該使用相鄰的字串來連接字串字面值。
*   建議使用插補來組成字串和值。
*   避免在不需要時在插補中使用大括號。

##### 集合

*   應該盡可能使用集合字面值。
*   不應該使用 `.length` 來檢查集合是否為空。
*   避免使用帶有函式字面值的 `Iterable.forEach()`。
*   不應該使用 `List.from()`，除非你打算改變結果的類型。
*   應該使用 `whereType()` 按類型篩選集合。
*   不應該在附近的操作可行時使用 `cast()`。
*   避免使用 `cast()`。

##### 函式

*   應該使用函式宣告將函式綁定到名稱。
*   不應該在淚脫關閉可行時建立 lambda。

##### 變數

*   應該在區域變數上為 `var` 和 `final` 遵循一致的規則。
*   避免存儲可以計算的內容。

##### 成員

*   不應該不必要地將欄位包裝在取得方法和設定方法中。
*   建議使用 `final` 欄位來建立唯讀屬性。
*   考慮對簡單成員使用 `=>`。
*   不應該使用 `this.`，除非重新導向到具名建構函式或避免遮蔽。
*   應該盡可能在欄位宣告時初始化欄位。

##### 建構函式

*   應該盡可能使用初始化形式參數。
*   不應該在建構函式初始化程式清單可行時使用 `late`。
*   應該對空建構函式主體使用 `;` 而不是 `{}`。
*   不應該使用 `new`。
*   不應該冗餘地使用 `const`。

##### 錯誤處理

*   避免沒有 `on` 子句的捕捉。
*   不應該從沒有 `on` 子句的捕捉中丟棄錯誤。
*   應該只為程式設計錯誤拋出實現 `Error` 的物件。
*   不應該明確地捕捉 `Error` 或實現它的類型。
*   應該使用 `rethrow` 重新拋出捕獲的例外。

##### 非同步

*   建議使用 async/await 而不是原始期貨。
*   不應該在 `async` 無有用效果時使用它。
*   考慮使用高階方法來轉換串流。
*   避免直接使用 Completer。
*   應該在消除類型引數可能為 `Object` 的 `FutureOr<T>` 時測試 `Future<T>`。

#### 設計

##### 名稱

*   應該一致地使用術語。
*   避免使用縮寫。
*   建議將最具描述性的名詞放在最後。
*   考慮讓程式碼像句子一樣讀取。
*   建議對非布林屬性或變數使用名詞片語。
*   建議對布林屬性或變數使用非命令式動詞片語。
*   考慮省略具名布林參數的動詞。
*   建議對布林屬性或變數使用「正面」名稱。
*   建議對其主要目的是副作用的函式或方法使用命令式動詞片語。
*   如果函式或方法的主要目的是傳回值，建議使用名詞片語或非命令式動詞片語。
*   如果你想吸引注意它執行的工作，考慮對函式或方法使用命令式動詞片語。
*   避免使用 `get` 開始方法名稱。
*   如果將物件的狀態複製到新物件，建議將方法命名為 `to...()`。
*   如果方法傳回由原始物件支援的不同表示，建議將方法命名為 `as...()`。
*   避免在函式或方法的名稱中描述參數。
*   應該在命名類型參數時遵循現有的助記符慣例。

##### 函式庫

*   建議將宣告設為私有。
*   考慮在同一函式庫中宣告多個類別。

##### 類別和 mixin

*   避免在簡單函式可行時定義單一成員的抽象類別。
*   避免定義只包含靜態成員的類別。
*   避免擴充不打算被子類別化的類別。
*   應該使用類別修飾符來控制你的類別是否可以被擴充。
*   避免實現不打算用作介面的類別。
*   應該使用類別修飾符來控制你的類別是否可以用作介面。
*   建議定義純 `mixin` 或純 `class` 而不是 `mixin class`。

##### 建構函式

*   考慮在類別支援時將建構函式設為 `const`。

##### 成員

*   建議將欄位和頂層變數設為 `final`。
*   應該對概念上存取屬性的操作使用取得方法。
*   應該對概念上改變屬性的操作使用設定方法。
*   不應該在沒有對應取得方法的情況下定義設定方法。
*   避免使用執行時類型測試來偽造多載。
*   避免公開的 `late final` 欄位而不初始化。
*   避免傳回可為空的 `Future`、`Stream` 和集合類型。
*   避免從方法傳回 `this` 只是為了啟用流暢介面。

##### 類型

*   應該對沒有初始化程式的變數進行類型註解。
*   如果類型不明顯，應該對欄位和頂層變數進行類型註解。
*   不應該冗餘地對初始化的區域變數進行類型註解。
*   應該在函式宣告上註解傳回類型。
*   應該在函式宣告上註解參數類型。
*   不應該在函式運算式上註解推斷的參數類型。
*   不應該對初始化形式參數進行類型註解。
*   應該對未推斷的泛型呼叫寫入類型引數。
*   不應該對推斷的泛型呼叫寫入類型引數。
*   避免撰寫不完整的泛型類型。
*   應該使用 `dynamic` 進行註解，而不是讓推斷失敗。
*   建議在函式類型註解中使用簽章。
*   不應該為設定方法指定傳回類型。
*   不應該使用舊版 typedef 語法。
*   建議使用內嵌函式類型而不是 typedef。
*   建議對參數使用函式類型語法。
*   避免使用 `dynamic`，除非你想停用靜態檢查。
*   應該將 `Future<void>` 用作不產生值的非同步成員的傳回類型。
*   避免使用 `FutureOr<T>` 作為傳回類型。

##### 參數

*   避免位置布林參數。
*   如果使用者可能想省略較早的參數，避免使用選用位置參數。
*   避免接受特殊「無引數」值的強制參數。
*   應該使用涵蓋開始和排除結束的參數來接受範圍。

##### 相等

*   如果你覆寫 `==`，應該覆寫 `hashCode`。
*   應該讓你的 `==` 運算子遵循相等的數學規則。
*   避免為可變類別定義自訂相等。
*   不應該讓 `==` 的參數可為空。

---

## Flutter 架構建議

本頁面呈現架構最佳實踐、為什麼它們很重要，
以及我們是否建議它們用於你的 Flutter 應用程式。
你應該將這些建議視為建議，
而不是堅定的規則，你應該
根據你應用程式的獨特需求調整它們。

本頁面上的最佳實踐有優先級，
這反映了 Flutter 團隊推薦它的強度。

* **強烈建議：** 如果你正在開始建立新應用程式，你應該始終實現此建議。你應該強烈考慮重構現有應用程式以實現此做法，除非這樣做會與你當前的方法根本衝突。
* **建議**：此做法可能會改進你的應用程式。
* **有條件**：此做法可以在特定情況下改進你的應用程式。

### 關注點分離

你應該將應用程式分離為 UI 層和資料層。在這些層內，你應該進一步按責任將邏輯分離到類別中。

#### 使用清楚定義的資料和 UI 層。
**強烈建議**

關注點分離是最重要的架構原則。資料層向應用程式的其餘部分公開應用程式資料，並包含應用程式中大部分業務邏輯。UI 層顯示應用程式資料並監聽來自使用者的使用者事件。UI 層包含 UI 邏輯和小工具的單獨類別。

#### 在資料層中使用存放庫模式。
**強烈建議**

存放庫模式是一種軟體設計模式，它將資料存取邏輯與應用程式的其餘部分隔離。它在應用程式的業務邏輯和基礎資料儲存機制（資料庫、API、檔案系統等）之間建立抽象層。實際上，這意味著建立存放庫類別和服務類別。

#### 在 UI 層中使用 ViewModel 和 View。(MVVM)
**強烈建議**

關注點分離是最重要的架構原則。這種特定的分離使你的程式碼更不容易出錯，因為你的小工具保持「啞」。

#### 使用 `ChangeNotifiers` 和 `Listenables` 來處理小工具更新。
**有條件**

> 有許多選項可以處理狀態管理，最終決定取決於個人偏好。

`ChangeNotifier` API 是 Flutter SDK 的一部分，是一種方便的方式來讓你的小工具觀察 ViewModel 中的更改。

#### 不要在小工具中放置邏輯。
**強烈建議**

邏輯應該封裝在 ViewModel 上的方法中。檢視應該只包含的邏輯是：
* 簡單的 if 陳述式，根據 ViewModel 中的旗標或可為空欄位來顯示和隱藏小工具
* 依賴小工具計算的動畫邏輯
* 基於裝置資訊的佈局邏輯，如螢幕大小或方向。
* 簡單的路由邏輯

#### 使用領域層。
**有條件**

> 在具有複雜邏輯需求的應用程式中使用。

只有在你的應用程式具有超出複雜邏輯的情況下，才需要領域層，這些邏輯擁擠你的 ViewModel，或者你發現自己在 ViewModel 中重複邏輯。在非常大的應用程式中，使用案例很有用，但在大多數應用程式中，它們會增加不必要的開銷。

### 處理資料

小心處理資料使你的程式碼更容易理解、更不容易出錯，並
防止建立格式不正確或意外的資料。

#### 使用單向資料流。
**強烈建議**

資料更新應該只從資料層流向 UI 層。UI 層中的互動被發送到資料層，在那裡進行處理。

#### 使用 `Commands` 來處理來自使用者互動的事件。
**建議**

Commands 防止應用程式中的呈現錯誤，並標準化 UI 層如何將事件發送到資料層。

#### 使用不可變資料模型。
**強烈建議**

不可變資料對於確保任何必要的更改只在適當的位置（通常是資料層或領域層）進行至關重要。由於不可變物件在建立後無法修改，你必須建立新實例以反映更改。此過程防止了 UI 層中的意外更新，並支援清楚的單向資料流。

#### 使用 freezed 或 built_value 產生不可變資料模型。
**建議**

你可以使用套件來幫助在資料模型中產生有用的功能，`freezed` 或 `built_value`。這些可以產生常見的模型方法，如 JSON 序列化/反序列化、深度相等檢查和複製方法。如果你有很多模型，這些程式碼產生套件可以為應用程式增加顯著的建置時間。

#### 建立單獨的 API 模型和領域模型。
**有條件**

> 在大型應用程式中使用。

使用單獨的模型會增加冗長性，但防止了 ViewModel 和使用案例中的複雜性。

### 應用程式結構

組織良好的程式碼對應用程式本身的健康和處理程式碼的團隊都有益。

#### 使用相依性注入。
**強烈建議**

相依性注入防止應用程式具有全域可存取的物件，這使你的程式碼更不容易出錯。我們建議你使用 `provider` 套件來處理相依性注入。

#### 使用 `go_router` 進行導航。
**建議**

Go_router 是編寫 90% Flutter 應用程式的首選方式。有一些 go_router 不解決的特定使用案例，在這種情況下，你可以直接使用 `Flutter Navigator API` 或嘗試在 `pub.dev` 上找到的其他套件。

#### 為類別、檔案和目錄使用標準化的命名慣例。
**建議**

我們建議根據類別代表的架構元件來命名類別。例如，你可能具有以下類別：

* HomeViewModel
* HomeScreen
* UserRepository
* ClientApiService

為清晰起見，我們不建議使用可能與 Flutter SDK 中的物件混淆的名稱。例如，你應該將共用的小工具放在名為 `ui/core/` 的目錄中，而不是名為 `/widgets` 的目錄。

#### 使用抽象存放庫類別
**強烈建議**

存放庫類別是應用程式中所有資料的真實來源，並促進與外部 API 的通訊。建立抽象存放庫類別使你可以建立不同的實現，這些實現可用於不同的應用程式環境，例如「開發」和「暫存」。

### 測試

良好的測試做法使應用程式更靈活。它也使新增邏輯和新增 UI 變得簡單和低風險。

#### 分別和一起測試架構元件。
**強烈建議**

* 為每個服務、存放庫和 ViewModel 類別編寫單位測試。這些測試應該分別測試每個方法的邏輯。
* 為檢視編寫小工具測試。測試路由和相依性注入特別重要。

#### 製作用於測試的假檢查對象（並編寫利用假檢查對象的程式碼。）
**強烈建議**

假檢查對象不如關注輸入和輸出那麼關注任何給定方法的內部工作原理。如果你在編寫應用程式程式碼時牢記這一點，你將被迫編寫具有明確定義的輸入和輸出的模組化、輕量級函式和類別。
